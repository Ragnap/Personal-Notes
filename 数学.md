# GCD & LCM

## 整除

### 定义

若$\displaystyle a\%b=0$​​​​​，则称b整除a（a被b整除）

### 表示

b整除a： $\displaystyle a|b  \Leftrightarrow  a\%b=0$​ 

### 性质

1. $\displaystyle a\ |\ b  \Leftrightarrow  (-a)|\ b  \Leftrightarrow   abs(a)|abs(b)$​​​
2. $\displaystyle a\ |\ b ,b\ |\ c  \Leftrightarrow a\ |\ c$​
3. $\displaystyle a\ |\ b , a\ |\ c \Leftrightarrow \exist\ x,y\ , \ a|\ bx+cy$​​​​​ 
4. $\displaystyle m \neq 0 , a\ |\ b \Leftrightarrow ma\ |\ mb$​
5. $\displaystyle a\ |\ b,b\ |\ a \Leftrightarrow b=±a$​

## 基于整除的专有名词

### 因数（约数）

所有满足 $\displaystyle a|b$ 的 $a$ 为 $ b$ 的全部因数（也就是说满足 $a|b$ 的 $a$ 就是 $b$ 的一个因数）

#### 		性质

​	**成对出现**：$\displaystyle d_1,d_2,d_3,\cdots$​​为 $b$​ ​的全部约数  ${\displaystyle\Leftrightarrow \frac{b}{d_1},\frac{b}{d_2},\frac{b}{d_3},\normalsize\cdots}$​​为b的全部约数

（也就是说如果确定了 $d_1$ 是约数，那么 $\displaystyle \frac{b}{d_1}$​ 肯定也是另一个约数）

### 质数

约数只有$1$​​​和自身的**自然数**

#### 	质数的数量  

  *用于时间复杂度分析和取数组大小*

$1\sim n$​中质数数量的上界约为$\displaystyle\frac{n}{\ln n}$​​​​

​								  下界约为 $\displaystyle\log_2(\log_2x)$

### 合数

能被除了$1$​​和自身的其他正整数整除的**自然数**

​	==*易错：0、1既非质数也非合数，但是注意题干上是**非质数**（含0，1）还是**合数**（不含0，1）*==

## 筛法

### 埃筛

埃拉托斯特尼筛法的缩写，EraSieve    *~~（这个英文其实是为了方便做函数名不要再写shake了）~~*

它的核心思想其实是当确认了一个数是质数以后，把它的所有倍数打上标记说这玩意不是质数。那现在的问题就只剩下怎么确定一个数是不是质数了。

###### 原理

我们先这样想，如果一个数 $n$​​ 是合数，那么一定可以表示为 $a*b$​​ , 其中 $a、b$​​ 都不能等于 $1$​​ 和 $n$​​ ，那这样的话 $a、b$​​ 都一定会是小于 $n$​​ 的，也就是说如果我们在$2\sim n$​​ 遍历的话，只要 $n$​​​ 是合数，那么它一定会在遍历到它之前被筛掉（相当于是它是某个小于它的数的倍数）。那么我们只需要从 $2$​​​ 开始遍历，记录每一个数有没有被筛掉，如果在遍历的它的时候没有被筛过，那么它就一定是质数（相当于是它不能表示为某个小于它的数的倍数，大于它的数就更不可能）。

###### 代码

```c++
int not_pri[MX]={0};//not_pri[i]表示i这个数是否为质数，质数为0，非质数为1
void EraSieve(int range){//筛出所有小于range的质数
    not_pri[1]=0;//如果想让not_pri表示非合数，那么这里需要让not_pri[1]=1
	for(int i=2;i<=range;i++){
        if(not_pri[i]==0){//如果i不是质数，那么它就没有必要再翻倍，因为它的倍数必然可以表示为它的某个质因数的倍数,所以必定已经被筛过了
            for(int j=2;i*j<=range;j++){
                not_pri[i*j]=1;//筛除倍数
            }
        }
    }
}
```

###### 复杂度分析

时间复杂度：$O(n\log\log n)$​  (范围*质数个数)

### 欧拉筛

也叫线性筛，EulerSieve    *~~（还是方便的函数名）~~*

欧拉筛其实是针对埃筛的超级优化，它们的大致想法是一样的，都是把质数的倍数打上标记来筛掉合数，埃筛的花时间主要是在筛掉倍数，我们继续想一想埃筛的遍历方式里面是不是有针对合数的倍数的剪枝，但是我们来看这样一个例子：

当$i=2$的时候，筛掉了$\ \ 4,\ \ 6,\ \ 8,10,12,14,16,18\dots$ 

当$i=3$​的时候，筛掉了$\ \ 6,\ \ 9,12,15,18,21,24,27\dots$​​ 

你会发现，虽然我们只筛掉质数的倍数，但是在上面那个例子里，所有 $6$​ 的倍数都会被筛两遍，那如果一个数有多个质因子呢？重复筛的次数是不是更多了？是不是就造成了更多的无用循环？那么这个只根据是不是质数进行剪枝是不是可以更加精准呢？所以欧拉筛就诞生了。

**让每一个数只被它最小的质因数筛到**，就是欧拉筛改进后的剪枝方法，也是欧拉筛的核心思想。那具体要怎么实现呢？

###### 原理

我们拿 $12$ 做一个例子，按照我们埃筛的方式来，会这样反复的筛掉 $12$ : $2*6=3*4$ 。想办法只用$2*6$来筛掉 $12$ 就可以了，我们可以发现一个数除以它最小的质因数得到的数一定是它最大的因数（$2*6$），而其他的表示方法一定可以分解成更小的质因数相乘的形式（$3*4=3*2*2=2*6$），也就是说如果一个数 $n$ 除以一个质因数 $x$ 得到的数 $y$ 是一个比这个质数 $x$ 更小的质数的倍数，那么这个质数 $x$ 就一定不是最小的质数，自然也就不用这个质数来筛了。 结合 $12$ 的例子来理解一下这句话：$n=12,x=3$ 得 $y=12 /3=4\ $,因为$\ 4=2*2\ , \ 2<3$，所以 $3$​ 不是最小质数。

其实这样麻烦的判别方法对于单个单个的数来说肯定不是最优的（直接挨个枚举$2\sim\sqrt{n}$​​看是不是整除岂不是更简单），之所以要用这样的一个性质，是因为我们需要筛啊，筛就需要枚举倍数，所以需要找一个通过倍数的关系来确定是不是最小质因数的性质。

接着看，可以发现只要是任何一个大于 $2$ 的质数 $x$ 来乘上 $4$ 得到的准备筛掉的数一定可以写成 $2*2x$的形式，就是说它的最小质因数肯定就不是 $x$ 了，而是 $2$ 了，那么就没有必要继续将之后的质数都没有必要筛掉他们的 $4$ 倍，因为他们的 $4$ 倍数肯定可以被 $2$ 筛掉。更一般化的形式就是，如果正在筛掉一个质数$x$的$y$倍，而这个 $y$ 能被一个比 $x$ 小的质数 $z$ 整除，所以 $x*y$ 一定可以表示为 $z*k$  ,而 $z$ 是比 $x$ 小的，回到欧拉筛的核心思想：“每一个数只被它最小的质因数筛到”，所以所有大于 $x$ 的质数都不用筛 $y$ 倍了，因为一定可以在筛去 $z$ 的 $k$ 倍时筛去。（这里可以求出来$\displaystyle k=\frac{x*y}{z}$）;

为了用上这个那我们再改一下筛的方法，埃筛的方法是通过枚举一次性把这个质数的所有倍数全部标记完，而欧拉筛是枚举质数的乘数，每一次标记上目前所有已知质数的某个确定的倍数（比如说都筛去目前已所有质数的$3$倍，下一次筛去所有已知质数的 $4$ 倍，每筛一次单个质数最多只会多一倍），这样就可以利用到上两段发现的性质来进行优化了。而这里的枚举倍数再仔细一看，其实可以利用埃筛里枚举的 $i$ ，$i$​ 在这里有了两个意义：①当前需要判断是不是质数的数；②所有质数筛去的倍数。

###### 代码

```c++
int pri[MX]={0};// pri[i]储存质数表，其中pri[0]表示这个质数表里有多少个数
int not_pri[MX]={0};//同埃筛里的not_pri[]
void EularSieve(int range){
    for(int i=2;i<range;i++){
        //i的第一个意义：判断i是不是质数，判断理由和埃筛一模一样
        if(not_pri[i]==0)
            pri[++pri[0]]=i;
        //i的第二个意义：筛去 目前所有已知质数*i 得到的合数
        for(int j=1;j<=pri[0];j++){//枚举当前已知质数
            if(pri[j]*i>range)break;//超出判断范围
            not_pri[pri[j]*i]=1;
 			//重点！
            if(i%pri[j]==0)break;
        	//用上面一般化的形式来表述的话,x=pri[j],y=i,这里由于pri是递增的，所以就相当于是判断y能不能被更小的质因数整除
            //如果i%pri[i]为0了，那么就找到了一个比x小的质数z,那么之后的倍数的最小的质因数就不再是x而是z了，所以不用接着筛了
        }
    }
}
```

###### 复杂度分析

时间复杂度：$O(n)$​​​​​  (每个数只被筛去一次)

## 唯一分解定理

(质因数分解)  所有大于 $1$ 的正整数都可以被唯一表示**有限个质数的乘积形式**（这个形式又可以叫标准分解式）
$$
\displaystyle\forall n\in N^+ ,n\neq1, n=p_1^{\alpha_1}*p_2^{\alpha_2}*\dots*p_n^{\alpha_n}
\ ,\mbox{其中 }p_1<p_2<\dots<p_n\mbox{ 且全为质数},\alpha_i\neq0
$$

###### 原理

通过筛法得到一个质数表，挨个挨个除，能整除多少次那这个质数就有多少次幂。枚举质数的范围应该是$2\sim \sqrt{n}$​​​（这个的原因请看推论-因数的合数大小）。这样把成对的因数除完还有可能剩下一个单独的质因数，再单独加到分解的结果中就可以了。*当然数据小的话不用质数表直接挨个枚举也应该不是问题*

###### 代码

（变量名与公式中的各项保持一致）

```c++
int pri[MX];//预处理完成后得到的质数表
int p[MX],a[MX];//p记录所有质因数的值,a记录所有质因数的幂,(记录方式和之前的pri记录方式一样)
void PrimeDevide(int num){
    for(int i=1;i<pri[0] && pri[i]*pri[i]<=num;i++){
        if(num%pri[i]==0){//找到因数
            p[++p[0]]=pri[i];
            while(num%pri[i]==0){//将该因数除去并根据循环次数统计幂
                a[p[0]]++;
                num/=pri[i];
            }
        }
    }
    if(num!=1){//可能剩下单个质因数
        p[++p[0]]=num;
        a[p[0]]=1;
    }
}
```



### 推论

#### 合数的因数大小

 若 $n$​​​​​​​ 为合数，则其标准分解式中必满足 $\exist \ p\ |\ n,\ p\leq \sqrt{n}$​​​​​​​​  *（这个其实相当于是约数的性质）*

##### 		理解

因为因数必然是成对存在的嘛，一个小于$\sqrt n$​​，一个大于$\sqrt n$​​，（假设两个都小于，那么这两个的乘积一定小于 $n$​​ ；假设两个都大于，那么这两个的乘积一定大于 $n$​​ 。两个假设都矛盾，原结论得证）所以这个推论其实可以表示为**通过确定 $1\sim \sqrt{n}$ ​​范围的所有因数就可以找到 $n$ 所有成对的因数**

#### 因数个数公式

通过对标准分解式中各个质因数的组合可以枚举出所有的因数，而这里组合的方案数就是因数的个数，它与标准分解式中质因数的指数是满足乘法原理的：（这里设因数个数为 $x$ )
$$
x=(\alpha_1+1)*(\alpha_2+1)*\dots*(\alpha_n+1)，\mbox{其中 }\alpha_i\mbox{ 是 }p_i\mbox{ 的指数}
$$

##### 		理解

对于 $n$ 的每一个因数，都必然也可以用 $n$ 的标准分解式的形式表示出来，不过有一点不同：$\alpha_i$在这里是可以取到0的（也就是说这个因数不包含$p_i$这个质因子）。当我们要通过标准分解式构造因数时，每一个质因子的指数的不同的取法就是 $0\sim\alpha_i$ 一共 $\alpha_i+1$ 种，而且每一个质因子取多少次幂是独立的，那么总共取出来的方案数也就必然满足乘法原理，那么乘起来就好啦

#### 因数和公式

同样是通过改变标准分解式中质因数的指数来计算的，只不过我们将单纯的质数相乘变成了这样：（这里设因数和为$sum$）
$$
\begin{align}
sum&=(p_1^{\alpha_1}+p_1^{\alpha_1-1}+\dots+1)*(p_2^{\alpha_2}+p_2^{\alpha_2-1}+\dots+1)*\dots*(p_n^{\alpha_n}+p_n^{\alpha_n-1}+\dots+1)
\\
&=\frac{p_1^{\alpha_1}-1}{p_1-1}*\frac{p_2^{\alpha_2}-1}{p_2-1}*\dots*\frac{p_n^{\alpha_n}-1}{p_n-1}，\mbox{其中 }\alpha_i\mbox{ 是 }p_i\mbox{ 的指数}
\end{align}
$$

##### 		理解

如果只看一个质因数，那么在固定其他的情况下，这个因数就可以为因数和做出它所有次幂的贡献，然后还是乘起来就行啦





# 逆元

## 阶乘逆元

