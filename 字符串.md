# Hash

Hash算法（哈希算法）实际上就是将一串数据（一般是数组或字符串）通过一些特定的方法转化成可以代表这些数据的一个数（Hash值）。通过哈希就可以快速的完成对这一串数据的一些比较，比如说当你要检验很多组字符串之间有哪些是一样的，就可以先算出各个字符串的Hash值，再通过比较Hash值是不是一样来替代更慢的普通字符串比较。

或者说Hash是一种从大范围到小范围的映射，数组或者字符串是一组大范围的数据，而通过Hash处理后得到的Hash值就是一个小范围的数据（一般是一个整型）。

从再数学一点的角度来看，Hash就是一个数学函数，你给它一些数据，它给你一个特征值。你给它的数据只能转化成一个特征值，同时理想状态下一个特征值只对应一组数据。

要想做到让这个Hash值能够代表这一串数据，就需要使用乘法或者位运算（或者全都要）。

## Hash冲突

由于Hash实际上是通过一些运算来计算出Hash值，所以有可能会出现明明是两个不同的字符串 $a , b $ ，但是最后却得到了一样的Hash值( $hash(a)==hash(b)$ )，这种情况我们就叫做Hash冲突。

当然并不是Hash所有都一定会有冲突（康托展开就是一个很好的例子），但是在面对由于数据太多的而不能保证无冲突的时候，我们要做的就是选择一个最好的Hash方式来尽可能的减小Hash冲突的发生率来保证运行结果的正确性。

## Hash种类

Hash有超级多种，如果想要Hash冲突率更低，可以：

1. 使用单独的一种hash，但通过改变乘数或者余数得到多组hash值来同时进行比较

2. 使用多种不同的hash，得到多组hash值同时比较

3. 使用hash表，将同一hash值的冲突的数据存在一个链表里，存在冲突时通过访问列表里的所有元素来确定

   ……

反正方法有很多

### 乘法Hash（进制Hash）

最基本也是花样最多的一种哈希。（好像还叫BKDRHash）

核心思想就是把字符串**看成是一个26进制的数组**（这个是对于纯小写\纯大写的字符串，如果加上数字就是36进制，如果区分大小写就是52进制……）然后把他换算回十进制。

如果不能确定取多少作为乘数的话，那就取33就行（好像如果进制数大于33，乘数取33也是不错的）。取31的原因主要有两点：	

1. ​    33是一个奇质数（~~*虽然偶质数就那一个*~~），它可以保证因数最少，从而尽可能减少哈希冲突的发生；
2. ​    33在进行乘法运算时会更快，因为 $x*33$​​ 可以被优化成 $(x<<5)+x$​​

如果得到的十进制数超出了 int 或者 long long 的范围，有下面几种方式来处理：

1. ​    **使用unsigned**让它随便溢出，反正溢出了还是非负数；

2. ​    取模:

   ​		哈希里关于取模的模数（哈希因子）该怎么取是一个非常经验的东西，[这里有一个常用哈希模数表](https://planetmath.org/goodhashtableprimes)，或者直接记两个：int  范围内 ：$402653189$  ; long long 范围内：$212370440130137957$ （其实直接拿 $1e7+7$ 和 $1e9+9$ 也是可以的）

代码的话就是这样：

```c++
ull hash(string x){
	ull res=0;
	int hash_base=33;
	//int hash_mod=402653189;
	for(int i=0;i<x.length();i++){
		res=res*base+x[i];
		//res%=hash_mod;
	}
	return hash;
}
```

### 位运算Hash

位运算的hash快的飞起    ~~***而且也很好记***~~

它主要是通过异或和移位来让每一个数据都能影响到最后的hash值。相当于是让hash值的不同几位保存几个数据异或的结果。

代码的话是这样：

```c++
ull hash(string x){
	ull res=0;
	for(int i=0;i<x.length();i++){
		res=(res<<4)^(res>>28)^x[i];
	}
	return res;
}
```



### FNVHash

乘法Hash的一种高级变种玩意。全称叫 Fowler-Noll-Vo算法

它同时使用位运算和乘法来计算hash值。这玩意就是硬记一下hash[初始值和乘数](http://www.isthe.com/chongo/tech/comp/fnv/#FNV-param)（**这个是固定的对应值，不要乱改**）：

| hash值位数 |      hash初始值      |     乘数      |
| :--------: | :------------------: | :-----------: |
|   32 位    |      2166136261      |   16777619    |
|   64 位    | 14695981039346656037 | 1099511628211 |

代码的话就是这样：

```c++
ull hash(string x){
	ull res=2166136261;
	int FNV_prime=16777619;
	for(int i=0;i<x.length();i++){
		hash^=x[i];
        hash*=FNV_prime;
	}
	return hash;
}
```

 其实上面这个是FNVHash的一种，叫FNV-1a ,还有就是交换了一下异或和乘的顺序的FNV-1 ~~([他们说FNV-1a是要比FNV-1好一点，尽量用FNV-1a](http://www.isthe.com/chongo/tech/comp/fnv/#FNV-1))~~

## Hash的应用

其实只要扯到字符串判断啊、数组判断啊、枚举字符串减少重复枚举啊都可以用hash~~（想用就用就行）~~

### 子串判断

~~（其实这玩意应该说是乘法hash的应用）~~

根据乘法hash的性质,我们可以得到这样一个递推求hash的方法：( 其实就是拿数组存了普通乘法hash里每一个的res值，相当于是当前字符串的hash值）

```
ull hash_val[1000010]={0};
ull hash(string x){
	int hash_base=33;
	for(int i=0;i<x.length();i++){
		hash=res*base+x[i];
	}
	return hash;
}
```

如果我们现在有一个字符串 $x$​​ ，我们现在想要求 $x[l]\sim x[r]$​​ 这个区间的子串的值，我们只需要知道 $hash\_val[l]$​​ 和 $hash\_val[r]$​​​ 就可以计算出这个子串的hash值：
$$
hash=hash\_val[r]-hash\_val[l-1]*base^{r-l+1}
$$

# Trie树

Trie树，字典树，前缀树

Trie树的出现主要是用于查找多个字符串是否出现或者统计出现次数。或者从它的另一个名字入手会更好理解一点：Trie就是在构造一个包含多个字符串的字典，所有能够类比查字典进行的操作都可以通过Trie来实现，比如说看一个字符串有没有出现过，就是在查字典，看有没有这个字符串。

当然这里的查字典肯定不是暴力的从第一个字符串一直遍历到最后一个字符串（~~那干嘛还要搞一个这个Trie~~）。想一下平时查字典的样子，是不是先找第一个字母、再找第二个字母直到最后一个字母。那Trie就是类似的查询操作。

Trie除了处理查询以外，还必须先实现的一个操作是构建字典。而在构建字典的时候如果使用树形的结构，树上的一个节点表示一个字母，而通过子节点和父节点的关系来表示字母出现的前后顺序，就能很方便通过树的遍历完成查字典的操作。同时一个父节点又可以有多个子节点，这样就提高了连续的查询效率。

## 建树

也就是先完成写好字典这个步骤。

先根据我们刚才的想法定义一下树的节点，它应该需要记录它的所有子节点（相当于是字典中这个字符串的存在的下一位字符有哪些）,还需要一个标记来标出这个字符是不是某一个字符串的结尾。那么这个节点自己的值呢？我们只需要利用当前节点中记录好的子节点信息来确定下一个节点，所以下一个节点的值可以直接通过父节点确定子节点的这个过程中得出了，所以就不需要再存当前节点的值了。（或者直接说是把子节点的值放在了边上）

在这里先假设所有字符串都是小写字母：

```c++
struct Node {
    int son[26];//全小写的字符串里下一个字符最多有26种（如果包含大小写，就应该是52，以此类推）
    //如果当前节点链接了字母x,那么son[x-'a']就表示字母x对应的子节点的编号
    //如果当前节点没链接字母x,那么son[x-'a']就等于0
    bool end;
    //表示当前节点是不是某一个字符串的结尾
    Node() {//初始化
        end = 0;
        for (int i = 0; i < 26; i++)
            son[i] = 0;
    }
}tr[1000010];
```

当我们确定了使用树结构后，首先需要确定树的根，但由于字符串的第一个字符可能有很多种，如果一个字符建一棵树就会很麻烦，所以我们在这里使用一个不表示任何字母的虚根，每一个字符的第一个字符都是这个虚根的子节点（最简单的设置虚根的做法就是拿编号为0的节点作为虚节点）。在那之后，我们只需要顺着树找子节点，如果有对应下一个字符的子节点就从这个子节点接着遍历字符串；如果没有呢？就新建一个子节点来对应当前字符就行啦：

```c++
int tr_cnt = 0;//统计当前Trie树中共有多少节点
void insert(string& x) {
    int u = 0;//表示当前节点编号，从根（0）开始遍历
    int v;//表示目标节点的值，就是下一位字符
    for (int i = 0; i < x.length(); i++) {
        v = x[i] - 'a';
        if (!tr[u].son[v])//字典里不存在下一个字符为v的子节点
            tr[u].son[v] = ++tr_cnt;//创建新的子节点，记录编号
        u = tr[u].son[v];//移动到对应的子节点，接着加入后面的字符
    }
    tr[u].end = 1;//遍历到的最后一个子节点就是这个字符串的结尾
}
```

## 查询

现在我们建好了Trie树，剩下的就是查询了。查询是求给定的字符串在不在字典中，查询的过程其实和创建的过程类似，只是如果字典里不存在某一个子节点的时候，我们需要的不是像建树那样的创建新节点，而是应该直接返回这个字符串不在字典中。以及还有可能有这种情况：字典里有以给定的字符串为前缀的字符串但是却没有这个字符串（比如字典里有abcd但是没有abc）,这样的话每一个子节点都是存在的，所以我们还需要判断一下字符串的结尾在字典中的节点有没有结尾标记：

```c++
bool check(string& x) {
    int u = 0, v;//与insert()里含义相同
    for (int i = 0; i < x.length(); i++) {
        v = x[i] - 'a';
        if (!tr[u].son[v])//字典里不存在下一个字符为v的子节点
            return 0;//与建树的不同点：直接判断字典里没有这个字符串
        u = tr[u].son[v];
    }
    //检测给定字符串的结尾在字典中的end标记
    return tr[u].end;
}
```

查询函数是Trie里最能整活的，比如说可以通过修改循环变量的初值与终止条件来达到判断子串的目标等等。

## 不同形式的模板

### 数组型

刚才我们所写的在每个节点中开了一个数组来存放子节点信息，这种做法的好处就是简便与方便调试。但数组型也有一个缺点，就算占用空间很大。每一个节点要有对应的26个的子节点，占用当然大。完整模板如下：

```c++
struct Node {
    bool end;
    int son[26];
    Node() {
        end = 0;
        for (int i = 0; i < 26; i++)
            son[i] = 0;
    }
}tr[50010];
int tr_cnt=0;
void insert(string& x) {
    int u=0, v, lenx = x.length();
    for (int i = 0; i < lenx; i++) {
        v = x[i] - 'a';
        if (!tr[u].son[v])
            tr[u].son[v] = ++tr_cnt;
        u = tr[u].son[v];
    }
    tr[u].end = 1;
}
bool check(string& x) {
    int u = 0, v;
    for (int i = 0; i < x.length(); i++) {
        v = x[i] - 'a';
        if (!tr[u].son[v])
            return 0;
        u = tr[u].son[v];
    }
    return tr[u].end;
}

```

### 指针型

为了解决数组型的内存困扰，改用了动态分配内存(new)的方法来消除了数组型结构体到底应该开多大的问题，大幅减少了内存的消耗。有一点麻烦的就是不太方便调试，而且指针操作容易出问题。改动后的模板如下：

```c++
struct Node {
    bool end;
    Node *son[26];
    Node() {
        end = 0;
        for (int i = 0; i < 26; i++)
            son[i] = NULL;
    }
}*root;//这里的root需要在执行insert前new一下，相当于是创建虚根
void insert(string& x) {
    Node* u=root;
    int v;
    for (int i = 0; i < x.length(); i++) {
        v = x[i] - 'a';
        if (u->son[v]==NULL)
            u->son[v] = new Node();
        u = u->son[v];
    }
    u->end = 1;
}
bool check(string& x) {
    Node* u = root;
    int v;
    for (int i = 0; i < x.length(); i++) {
        v = x[i] - 'a';
        if (u->son[v] == NULL)
            return 0;
        u = u->son[v];
    }
    return u->end;
}
```

## 复杂度

时间复杂度：$O(n)$​   n为所有待查询字符串的字符个数

空间复杂度：最坏 $O(k^m)$  k 为字典中的字符种数，m为字典中最长字符串长度

非常明显的可以看到，Trie树是拿空间换时间的做法，所以在使用时一定格外小心有没有MLE

# KMP算法

KMP算法是处理单主串多模式串的一种算法
